/**
 * PortX ORCA Account Management
 * PortX ORCA semantic and interaction is based on ISO 20022 and restricted to the US banking domain. The scope covers the following communication flows: bank account opening, maintenance, closing and reporting. In many cases, the financial institution will require additional documentation that is available as PDF or Word document. The recommended solution is to group one ORCA message (for example the account opening request) with these accompanying documents in one file archive. The archive establishes the link between the different documents. Every ORCA request message has an attribute to support the ISO 20022 digital signature.  
 *
 * The version of the OpenAPI document: 0.8.0
 * Contact: betiana.darderes@portx.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { Organization } from '../model/organization';
import { OrganizationDescriptor } from '../model/organizationDescriptor';
import { OrganizationRequest } from '../model/organizationRequest';
import { Person } from '../model/person';
import { PersonDescriptor } from '../model/personDescriptor';
import { PersonRequest } from '../model/personRequest';
import { PersonsResponse } from '../model/personsResponse';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class PartiesService {

    protected basePath = 'https://virtserver.swaggerhub.com/PortX/open-banking-accounts/1.0.16';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();

    constructor(protected httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Creates an Organization
     * 
     * @param organizationRequest 
     * @param idempotencyId Idempotency identifier used by the client when making repeated calls
     * @param servicerId Account Servicer Identification (Bank)
     * @param servicerBranchId Identification of the account servicer institution at branch level or center level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createOrganization(organizationRequest: OrganizationRequest, idempotencyId?: string, servicerId?: string, servicerBranchId?: string, ): Observable<AxiosResponse<Organization>>;
    public createOrganization(organizationRequest: OrganizationRequest, idempotencyId?: string, servicerId?: string, servicerBranchId?: string, ): Observable<any> {
        if (organizationRequest === null || organizationRequest === undefined) {
            throw new Error('Required parameter organizationRequest was null or undefined when calling createOrganization.');
        }

        let headers = {...this.defaultHeaders};
        if (idempotencyId !== undefined && idempotencyId !== null) {
            headers['idempotencyId'] = String(idempotencyId);
        }
        if (servicerId !== undefined && servicerId !== null) {
            headers['servicerId'] = String(servicerId);
        }
        if (servicerBranchId !== undefined && servicerBranchId !== null) {
            headers['servicerBranchId'] = String(servicerBranchId);
        }

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (openIdConnect) required
        // authentication (jwt) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<Organization>(`${this.basePath}/organizations`,
                    organizationRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Creates a Person
     * 
     * @param personRequest 
     * @param idempotencyId Idempotency identifier used by the client when making repeated calls
     * @param servicerId Account Servicer Identification (Bank)
     * @param servicerBranchId Identification of the account servicer institution at branch level or center level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createPerson(personRequest: PersonRequest, idempotencyId?: string, servicerId?: string, servicerBranchId?: string, ): Observable<AxiosResponse<Person>>;
    public createPerson(personRequest: PersonRequest, idempotencyId?: string, servicerId?: string, servicerBranchId?: string, ): Observable<any> {
        if (personRequest === null || personRequest === undefined) {
            throw new Error('Required parameter personRequest was null or undefined when calling createPerson.');
        }

        let headers = {...this.defaultHeaders};
        if (idempotencyId !== undefined && idempotencyId !== null) {
            headers['idempotencyId'] = String(idempotencyId);
        }
        if (servicerId !== undefined && servicerId !== null) {
            headers['servicerId'] = String(servicerId);
        }
        if (servicerBranchId !== undefined && servicerBranchId !== null) {
            headers['servicerBranchId'] = String(servicerBranchId);
        }

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (openIdConnect) required
        // authentication (jwt) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<Person>(`${this.basePath}/persons`,
                    personRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Retrieves an Organization
     * 
     * @param organizationId Organization Identification
     * @param servicerId Account Servicer Identification (Bank)
     * @param servicerBranchId Identification of the account servicer institution at branch level or center level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findOrganizationById(organizationId: string, servicerId?: string, servicerBranchId?: string, ): Observable<AxiosResponse<Organization>>;
    public findOrganizationById(organizationId: string, servicerId?: string, servicerBranchId?: string, ): Observable<any> {
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling findOrganizationById.');
        }

        let headers = {...this.defaultHeaders};
        if (servicerId !== undefined && servicerId !== null) {
            headers['servicerId'] = String(servicerId);
        }
        if (servicerBranchId !== undefined && servicerBranchId !== null) {
            headers['servicerBranchId'] = String(servicerBranchId);
        }

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (openIdConnect) required
        // authentication (jwt) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Organization>(`${this.basePath}/organizations/${encodeURIComponent(String(organizationId))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Retrieves a list of organizations matching the parameters.
     * 
     * @param paginationCursor Pagination Cursor
     * @param paginationTotal Total number of resources. 
     * @param nameInc The organization name includes the substring provided.
     * @param accountNumberEq The organization owns an account with the number.
     * @param tinEq 
     * @param emailEq Email equals to
     * @param addressLineInc Any address line of any postal address includes substring
     * @param postCodeEq Any postal address with post code equals to
     * @param countryEq Any postal address with country code equals to
     * @param countrySubDivisionInc Any postal address with country subdivision includes substring
     * @param townNameInc Any postal address with town name includes substring
     * @param organizationIdEq System id equals to
     * @param auditLastModificationDateLte 
     * @param dateOfBithEq 
     * @param auditLastModificationDateGte 
     * @param servicerId Account Servicer Identification (Bank)
     * @param servicerBranchId Identification of the account servicer institution at branch level or center level.
     * @param cursor Specifies an opaque string value ( \&quot;no  meaning\&quot; string value) at which start retrieving transactions. For instance, limit&#x3D;5&amp;cursor&#x3D;62aef884fbe3470ce7d9a92140b09b17 
     * @param limit Specifies the number of resources to return in one request, specified as an integer from 1 to 100. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findOrganizations(paginationCursor: string, paginationTotal: string, nameInc?: string, accountNumberEq?: string, tinEq?: string, emailEq?: string, addressLineInc?: string, postCodeEq?: string, countryEq?: string, countrySubDivisionInc?: string, townNameInc?: string, organizationIdEq?: string, auditLastModificationDateLte?: string, dateOfBithEq?: string, auditLastModificationDateGte?: string, servicerId?: string, servicerBranchId?: string, cursor?: string, limit?: string, ): Observable<AxiosResponse<Array<OrganizationDescriptor>>>;
    public findOrganizations(paginationCursor: string, paginationTotal: string, nameInc?: string, accountNumberEq?: string, tinEq?: string, emailEq?: string, addressLineInc?: string, postCodeEq?: string, countryEq?: string, countrySubDivisionInc?: string, townNameInc?: string, organizationIdEq?: string, auditLastModificationDateLte?: string, dateOfBithEq?: string, auditLastModificationDateGte?: string, servicerId?: string, servicerBranchId?: string, cursor?: string, limit?: string, ): Observable<any> {
        if (paginationCursor === null || paginationCursor === undefined) {
            throw new Error('Required parameter paginationCursor was null or undefined when calling findOrganizations.');
        }

        if (paginationTotal === null || paginationTotal === undefined) {
            throw new Error('Required parameter paginationTotal was null or undefined when calling findOrganizations.');
        }

        let queryParameters = new URLSearchParams();
        if (nameInc !== undefined && nameInc !== null) {
            queryParameters.append('name.inc', <any>nameInc);
        }
        if (accountNumberEq !== undefined && accountNumberEq !== null) {
            queryParameters.append('accountNumber.eq', <any>accountNumberEq);
        }
        if (tinEq !== undefined && tinEq !== null) {
            queryParameters.append('tin.eq', <any>tinEq);
        }
        if (emailEq !== undefined && emailEq !== null) {
            queryParameters.append('email.eq', <any>emailEq);
        }
        if (addressLineInc !== undefined && addressLineInc !== null) {
            queryParameters.append('addressLine.inc', <any>addressLineInc);
        }
        if (postCodeEq !== undefined && postCodeEq !== null) {
            queryParameters.append('postCode.eq', <any>postCodeEq);
        }
        if (countryEq !== undefined && countryEq !== null) {
            queryParameters.append('country.eq', <any>countryEq);
        }
        if (countrySubDivisionInc !== undefined && countrySubDivisionInc !== null) {
            queryParameters.append('countrySubDivision.inc', <any>countrySubDivisionInc);
        }
        if (townNameInc !== undefined && townNameInc !== null) {
            queryParameters.append('townName.inc', <any>townNameInc);
        }
        if (organizationIdEq !== undefined && organizationIdEq !== null) {
            queryParameters.append('organizationId.eq', <any>organizationIdEq);
        }
        if (auditLastModificationDateLte !== undefined && auditLastModificationDateLte !== null) {
            queryParameters.append('audit.lastModificationDate.lte', <any>auditLastModificationDateLte);
        }
        if (dateOfBithEq !== undefined && dateOfBithEq !== null) {
            queryParameters.append('dateOfBith.eq', <any>dateOfBithEq);
        }
        if (auditLastModificationDateGte !== undefined && auditLastModificationDateGte !== null) {
            queryParameters.append('audit.lastModificationDate.gte', <any>auditLastModificationDateGte);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }

        let headers = {...this.defaultHeaders};
        if (servicerId !== undefined && servicerId !== null) {
            headers['servicerId'] = String(servicerId);
        }
        if (servicerBranchId !== undefined && servicerBranchId !== null) {
            headers['servicerBranchId'] = String(servicerBranchId);
        }
        if (paginationCursor !== undefined && paginationCursor !== null) {
            headers['Pagination-Cursor'] = String(paginationCursor);
        }
        if (paginationTotal !== undefined && paginationTotal !== null) {
            headers['Pagination-Total'] = String(paginationTotal);
        }

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (openIdConnect) required
        // authentication (jwt) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<OrganizationDescriptor>>(`${this.basePath}/organizations`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Retrieves a Person
     * 
     * @param personId Person Identification
     * @param servicerId Account Servicer Identification (Bank)
     * @param servicerBranchId Identification of the account servicer institution at branch level or center level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findPersonById(personId: string, servicerId?: string, servicerBranchId?: string, ): Observable<AxiosResponse<Person>>;
    public findPersonById(personId: string, servicerId?: string, servicerBranchId?: string, ): Observable<any> {
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling findPersonById.');
        }

        let headers = {...this.defaultHeaders};
        if (servicerId !== undefined && servicerId !== null) {
            headers['servicerId'] = String(servicerId);
        }
        if (servicerBranchId !== undefined && servicerBranchId !== null) {
            headers['servicerBranchId'] = String(servicerBranchId);
        }

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (openIdConnect) required
        // authentication (jwt) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Person>(`${this.basePath}/persons/${encodeURIComponent(String(personId))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Retrieves a list of persons matching the parameters.
     * 
     * @param paginationCursor Pagination Cursor
     * @param paginationTotal Total number of resources. 
     * @param nameInc The person name includes the substring provided.
     * @param lastNameEq 
     * @param firstNameEq 
     * @param birthDateEq 
     * @param statusEq 
     * @param phoneNumberEq Any phone number equals to.
     * @param accountNumberEq 
     * @param cardNumberEq 
     * @param tinEq 
     * @param ssnEq Social Security Number
     * @param ssnLast4 Social Security Number last four digits.
     * @param emailEq Email equals to
     * @param addressLineInc Any address line of any postal address includes substring
     * @param postCodeEq Any postal address with post code equals to
     * @param countryEq Any postal address with Country code equals to
     * @param countrySubDivisionInc Any postal address with country subdivision includes substring
     * @param townNameInc Any postal address with town name includes substring
     * @param personIdEq System id equals to
     * @param auditLastModificationDateLte 
     * @param auditLastModificationDateGte 
     * @param cardNumberLast4 Card Number last four digits.
     * @param accountNumberLast4 Account Number last four digits.
     * @param personRoleEq Retrieves persons with the rol required. Possible values: CardHolder, Person. 
     * @param servicerId Account Servicer Identification (Bank)
     * @param servicerBranchId Identification of the account servicer institution at branch level or center level.
     * @param coreFormatMode &lt;CARD_NUMBER_MASKED|CARD_NUMBER_NOT_MASKED|ID_NOT_MASKED|ID_MASKED|NOT_MASKED|MASKED|&gt; Indicates the format of the API Response.  CARD_NUMBER_MASKED: Card number masked.  CARD_NUMBER_NOT_MASKED: Card number not masked.  ID_NOT_MASKED: Identifiers not masked.  ID_MASKED: Identifiers masked.  NOT_MASKED: All fields not masked.  MASKED: All masked. 
     * @param cursor Specifies an opaque string value ( \&quot;no  meaning\&quot; string value) at which start retrieving transactions. For instance, limit&#x3D;5&amp;cursor&#x3D;62aef884fbe3470ce7d9a92140b09b17 
     * @param limit Specifies the number of resources to return in one request, specified as an integer from 1 to 100. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findPersons(paginationCursor: string, paginationTotal: string, nameInc?: string, lastNameEq?: string, firstNameEq?: string, birthDateEq?: string, statusEq?: string, phoneNumberEq?: string, accountNumberEq?: string, cardNumberEq?: string, tinEq?: string, ssnEq?: string, ssnLast4?: string, emailEq?: string, addressLineInc?: string, postCodeEq?: string, countryEq?: string, countrySubDivisionInc?: string, townNameInc?: string, personIdEq?: string, auditLastModificationDateLte?: string, auditLastModificationDateGte?: string, cardNumberLast4?: string, accountNumberLast4?: string, personRoleEq?: string, servicerId?: string, servicerBranchId?: string, coreFormatMode?: string, cursor?: string, limit?: string, ): Observable<AxiosResponse<Array<PersonDescriptor>>>;
    public findPersons(paginationCursor: string, paginationTotal: string, nameInc?: string, lastNameEq?: string, firstNameEq?: string, birthDateEq?: string, statusEq?: string, phoneNumberEq?: string, accountNumberEq?: string, cardNumberEq?: string, tinEq?: string, ssnEq?: string, ssnLast4?: string, emailEq?: string, addressLineInc?: string, postCodeEq?: string, countryEq?: string, countrySubDivisionInc?: string, townNameInc?: string, personIdEq?: string, auditLastModificationDateLte?: string, auditLastModificationDateGte?: string, cardNumberLast4?: string, accountNumberLast4?: string, personRoleEq?: string, servicerId?: string, servicerBranchId?: string, coreFormatMode?: string, cursor?: string, limit?: string, ): Observable<any> {
        if (paginationCursor === null || paginationCursor === undefined) {
            throw new Error('Required parameter paginationCursor was null or undefined when calling findPersons.');
        }

        if (paginationTotal === null || paginationTotal === undefined) {
            throw new Error('Required parameter paginationTotal was null or undefined when calling findPersons.');
        }

        let queryParameters = new URLSearchParams();
        if (nameInc !== undefined && nameInc !== null) {
            queryParameters.append('name.inc', <any>nameInc);
        }
        if (lastNameEq !== undefined && lastNameEq !== null) {
            queryParameters.append('lastName.eq', <any>lastNameEq);
        }
        if (firstNameEq !== undefined && firstNameEq !== null) {
            queryParameters.append('firstName.eq', <any>firstNameEq);
        }
        if (birthDateEq !== undefined && birthDateEq !== null) {
            queryParameters.append('birthDate.eq', <any>birthDateEq);
        }
        if (statusEq !== undefined && statusEq !== null) {
            queryParameters.append('status.eq', <any>statusEq);
        }
        if (phoneNumberEq !== undefined && phoneNumberEq !== null) {
            queryParameters.append('phoneNumber.eq', <any>phoneNumberEq);
        }
        if (accountNumberEq !== undefined && accountNumberEq !== null) {
            queryParameters.append('accountNumber.eq', <any>accountNumberEq);
        }
        if (cardNumberEq !== undefined && cardNumberEq !== null) {
            queryParameters.append('cardNumber.eq', <any>cardNumberEq);
        }
        if (tinEq !== undefined && tinEq !== null) {
            queryParameters.append('tin.eq', <any>tinEq);
        }
        if (ssnEq !== undefined && ssnEq !== null) {
            queryParameters.append('ssn.eq', <any>ssnEq);
        }
        if (ssnLast4 !== undefined && ssnLast4 !== null) {
            queryParameters.append('ssn.last4', <any>ssnLast4);
        }
        if (emailEq !== undefined && emailEq !== null) {
            queryParameters.append('email.eq', <any>emailEq);
        }
        if (addressLineInc !== undefined && addressLineInc !== null) {
            queryParameters.append('addressLine.inc', <any>addressLineInc);
        }
        if (postCodeEq !== undefined && postCodeEq !== null) {
            queryParameters.append('postCode.eq', <any>postCodeEq);
        }
        if (countryEq !== undefined && countryEq !== null) {
            queryParameters.append('country.eq', <any>countryEq);
        }
        if (countrySubDivisionInc !== undefined && countrySubDivisionInc !== null) {
            queryParameters.append('countrySubDivision.inc', <any>countrySubDivisionInc);
        }
        if (townNameInc !== undefined && townNameInc !== null) {
            queryParameters.append('townName.inc', <any>townNameInc);
        }
        if (personIdEq !== undefined && personIdEq !== null) {
            queryParameters.append('personId.eq', <any>personIdEq);
        }
        if (auditLastModificationDateLte !== undefined && auditLastModificationDateLte !== null) {
            queryParameters.append('audit.lastModificationDate.lte', <any>auditLastModificationDateLte);
        }
        if (auditLastModificationDateGte !== undefined && auditLastModificationDateGte !== null) {
            queryParameters.append('audit.lastModificationDate.gte', <any>auditLastModificationDateGte);
        }
        if (cardNumberLast4 !== undefined && cardNumberLast4 !== null) {
            queryParameters.append('cardNumber.last4', <any>cardNumberLast4);
        }
        if (accountNumberLast4 !== undefined && accountNumberLast4 !== null) {
            queryParameters.append('accountNumber.last4', <any>accountNumberLast4);
        }
        if (personRoleEq !== undefined && personRoleEq !== null) {
            queryParameters.append('personRole.eq', <any>personRoleEq);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }

        let headers = {...this.defaultHeaders};
        if (servicerId !== undefined && servicerId !== null) {
            headers['servicerId'] = String(servicerId);
        }
        if (servicerBranchId !== undefined && servicerBranchId !== null) {
            headers['servicerBranchId'] = String(servicerBranchId);
        }
        if (coreFormatMode !== undefined && coreFormatMode !== null) {
            headers['Core-Format-Mode'] = String(coreFormatMode);
        }
        if (paginationCursor !== undefined && paginationCursor !== null) {
            headers['Pagination-Cursor'] = String(paginationCursor);
        }
        if (paginationTotal !== undefined && paginationTotal !== null) {
            headers['Pagination-Total'] = String(paginationTotal);
        }

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (openIdConnect) required
        // authentication (jwt) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.portx-orca.extended+json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<PersonDescriptor>>(`${this.basePath}/persons`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Updates an Organization
     * Use the JSON Merge Patch standard https://tools.ietf.org/html/rfc7396
     * @param organizationId Organization Identification
     * @param body 
     * @param servicerId Account Servicer Identification (Bank)
     * @param servicerBranchId Identification of the account servicer institution at branch level or center level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateOrganization(organizationId: string, body: object, servicerId?: string, servicerBranchId?: string, ): Observable<AxiosResponse<Organization>>;
    public updateOrganization(organizationId: string, body: object, servicerId?: string, servicerBranchId?: string, ): Observable<any> {
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling updateOrganization.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateOrganization.');
        }

        let headers = {...this.defaultHeaders};
        if (servicerId !== undefined && servicerId !== null) {
            headers['servicerId'] = String(servicerId);
        }
        if (servicerBranchId !== undefined && servicerBranchId !== null) {
            headers['servicerBranchId'] = String(servicerBranchId);
        }

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (openIdConnect) required
        // authentication (jwt) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<Organization>(`${this.basePath}/organizations/${encodeURIComponent(String(organizationId))}`,
                    body,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Updates a Person
     * Use the JSON Merge Patch standard https://tools.ietf.org/html/rfc7396
     * @param personId Person Identification
     * @param body 
     * @param servicerId Account Servicer Identification (Bank)
     * @param servicerBranchId Identification of the account servicer institution at branch level or center level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updatePerson(personId: string, body: object, servicerId?: string, servicerBranchId?: string, ): Observable<AxiosResponse<Person>>;
    public updatePerson(personId: string, body: object, servicerId?: string, servicerBranchId?: string, ): Observable<any> {
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling updatePerson.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePerson.');
        }

        let headers = {...this.defaultHeaders};
        if (servicerId !== undefined && servicerId !== null) {
            headers['servicerId'] = String(servicerId);
        }
        if (servicerBranchId !== undefined && servicerBranchId !== null) {
            headers['servicerBranchId'] = String(servicerBranchId);
        }

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (openIdConnect) required
        // authentication (jwt) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<Person>(`${this.basePath}/persons/${encodeURIComponent(String(personId))}`,
                    body,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
}
